import marked from "marked"

let renderer = new marked.Renderer()

renderer.tocTokens = []
renderer.heading = function (text, level, raw, slugger) {
  if (this.options.headerIds) {
    let anchor = this.options.headerPrefix + slugger.slug(raw)
    this.tocTokens.push({text, level, anchor})
    return `<h${level} id="${anchor}" class="markdown-body-anchor">${text}</h${level}>`
  }
  return `<h${level}>${text}</h${level}>`
}

marked.setOptions({
  renderer: renderer,
  headerPrefix: 'md'
})

function tocTokens2HTML(tokens) {
  let html = "<ul>",
    index = 0,
    level = 1,
    levelStack = ['</ul>']

  let tokensLength = tokens.length
  while (index < tokensLength) {
    if (tokens[index].level == level) {
      if (levelStack[levelStack.length - 1] == '</li>') {
        html += levelStack.pop() // html += '</li>'
      }
      html += `<li><a href="#${tokens[index].anchor}">${tokens[index].text}</a>`

      levelStack.push(`</li>`)
      index++
    } else if (tokens[index].level > level) {
      if (levelStack[levelStack.length - 1] == '</ul>') {
        html += `<li><ul>`
        levelStack.push(`</li>`)
        levelStack.push(`</ul>`)
      } else {
        html += `<ul>`
        levelStack.push('</ul>')
      }
      level++
    } else {
      for (let i = (level - tokens[index].level) * 2 + 1; i > 0; i--) {
        html += levelStack.pop()
      }
      level = tokens[index].level
    }
  }
  for (let i = levelStack.length; i > 0; i--) {
    html += levelStack.pop()
  }
  return html
}

let chain = function () {
  return {
    length: 0,
    index: 0,
    anchors: [],
    tocs: [],
    tocDOM: null,
    scroll: scroll
  }
}

function init(e, a, t) {
  e.chain.anchors = document.getElementById(a).getElementsByClassName("markdown-body-anchor")
  e.chain.tocDOM = document.getElementById(t)
  e.chain.tocs = e.chain.tocDOM.getElementsByTagName('a')
  e.chain.length = e.chain.tocs.length
  e.chain.tocs[e.chain.index].style.color = "#0099ff"
  window.addEventListener("scroll", function () {
    e.chain.scroll()
  })
}

function scroll() {
  let anchors = this.anchors,
    index = this.index,
    length = this.length,
    tocs = this.tocs

  function top(e) {
    return e.getBoundingClientRect().top
  }

  let distance = 30
  if (top(anchors[index]) < distance) {
    if (index > length - 2) return
    if (top(anchors[index + 1]) < distance) {
      tocs[this.index++].style.color = "#111"
      tocs[this.index].style.color = "#0099ff"
      if (top(tocs[index]) > window.innerHeight / 2.5) {
        this.tocDOM.scrollTop += top(tocs[index]) - window.innerHeight / 2.5;
      }
    } else {
      return
    }
  } else {
    if (index < 1) return
    tocs[this.index--].style.color = "#111"
    tocs[this.index].style.color = "#0099ff"
    if (top(tocs[index]) < window.innerHeight / 2) {
      this.tocDOM.scrollTop -= Math.abs(top(tocs[index]) - window.innerHeight / 2.5);
    }
  }
}

export default function (mdString = "", toc = false, opt, callback) {
  renderer.tocTokens = []
  let mdHTML = marked(mdString, opt, callback)

  if (!toc) {
    return {
      mdHTML: mdHTML
    }
  } else {
    return {
      mdHTML: mdHTML,
      tocHTML: tocTokens2HTML(renderer.tocTokens),
      init: init,
      chain: chain()
    }
  }
}